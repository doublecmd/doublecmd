Index: AbBitBkt.pas
===================================================================
--- AbBitBkt.pas	(revision 512)
+++ AbBitBkt.pas	(working copy)
@@ -47,7 +47,7 @@
       FBufPosn : longint;
       FPosn    : Int64;
       FSize    : Int64;
-      FTail    : longint;
+      FTail    : Int64;
     protected
     public
       constructor Create(aBufSize : cardinal);
@@ -108,8 +108,8 @@
 {--------}
 function TAbBitBucketStream.Read(var Buffer; Count : Longint) : Longint;
 var
-  Chunk2Size : longint;
-  Chunk1Size : longint;
+  Chunk2Size : Int64;
+  Chunk1Size : Int64;
   OutBuffer  : PByte;
 begin
   OutBuffer := @Buffer;
@@ -146,7 +146,7 @@
   end;
   if (Chunk2Size > 0) then begin
     {we've wrapped}
-    Move(FBuffer[0], PByte(PtrInt(OutBuffer) + PtrInt(Chunk1Size))^, Chunk2Size);
+    Move(FBuffer[0], (OutBuffer + Chunk1Size)^, Chunk2Size);
     FBufPosn := Chunk2Size;
     inc(FPosn, Chunk2Size);
   end;
@@ -155,8 +155,8 @@
 {--------}
 function TAbBitBucketStream.Write(const Buffer; Count : Longint) : Longint;
 var
-  Chunk2Size : longint;
-  Chunk1Size : longint;
+  Chunk2Size : Int64;
+  Chunk1Size : Int64;
   InBuffer   : PByte;
   Overage    : longint;
 begin
@@ -186,7 +186,7 @@
   {if the second chunk size is not zero, write the second chunk; note
    that we have wrapped}
   if (Chunk2Size > 0) then begin
-    Move(PByte(PtrInt(InBuffer) + PtrInt(Chunk1Size))^, FBuffer[0], Chunk2Size);
+    Move((InBuffer + Chunk1Size)^, FBuffer[0], Chunk2Size);
     FTail := Chunk2Size;
   end;
   {the stream size and position have changed}
Index: AbBrowse.pas
===================================================================
--- AbBrowse.pas	(revision 512)
+++ AbBrowse.pas	(working copy)
@@ -220,13 +220,15 @@
 uses
   SysUtils,
   AbExcept,
-{$IFDEF MSWINDOWS}
+{$IF DEFINED(ExtractCabSupport)}
   AbCabTyp,
 {$ENDIF}
   AbZipTyp,
   AbTarTyp,
   AbGzTyp,
-  AbBzip2Typ;
+  AbBzip2Typ,
+  DCOSUtils,
+  DCClassesUtf8;
 
 { TAbBaseBrowser implementation ======================================= }
 
@@ -515,68 +517,52 @@
 function AbDetermineArcType(const FN : string; AssertType : TAbArchiveType) : TAbArchiveType;
 var
   Ext : string;
-  FS : TFileStream;
+  FS : TStream = nil;
 begin
   Result := AssertType;
-  if Result = atUnknown then begin
+  { Guess archive type based on it's content }
+  if (Result = atUnknown) and mbFileExists(FN) and (AbFileGetSize(FN) > 0) then
+    try
+      FS := TFileStreamEx.Create(FN, fmOpenRead or fmShareDenyNone);
+      Result := VerifyZip(FS);
+      if Result = atUnknown then
+        Result := VerifySelfExtracting(FS);
+      if Result = atUnknown then
+        Result := VerifyTar(FS);
+      if Result = atUnknown then
+        Result := VerifyGzip(FS);
+      {$IF DEFINED(ExtractCabSupport)}
+      if Result = atUnknown then
+        Result := VerifyCab(FS);
+      {$ENDIF}
+      if Result = atUnknown then
+        Result := VerifyBzip2(FS);
+    finally
+      if Assigned(FS) then
+        FreeAndNil(FS);
+    end
+  else if Result = atUnknown then begin
     { Guess archive type based on it's extension }
     Ext := UpperCase(ExtractFileExt(FN));
     if (Ext = '.ZIP') or (Ext = '.JAR') then
-      Result := atZip;
-    if (Ext = '.EXE') then
-      Result := atSelfExtZip;
-    if (Ext = '.TAR') then
-      Result := atTar;
-    if (Ext = '.GZ') then
-      Result := atGzip;
-    if (Ext = '.TGZ') then
-      Result := atGzippedTar;
-    if (Ext = '.CAB') then
-      Result := atCab;
-    if (Ext = '.BZ2') then
-      Result := atBzip2;
-    if (Ext = '.TBZ') then
+      Result := atZip
+    else if (Ext = '.TAR') then
+      Result := atTar
+    else if (Ext = '.GZ') then
+      Result := atGzip
+    else if (Ext = '.TGZ') then
+      Result := atGzippedTar
+    else if (Ext = '.CAB') then
+      Result := atCab
+    else if (Ext = '.BZ2') then
+      Result := atBzip2
+    else if (Ext = '.TBZ') then
       Result := atBzippedTar;
   end;
-  {$IFNDEF MSWINDOWS}
+  {$IF NOT DEFINED(ExtractCabSupport)}
   if Result = atCab then
     Result := atUnknown;
   {$ENDIF}
-  if FileExists(FN) and (AbFileGetSize(FN) > 0) then begin
-    { If the file doesn't exist (or is empty) presume to make one, otherwise
-      guess or verify the contents }
-    FS := TFileStream.Create(FN, fmOpenRead or fmShareDenyNone);
-    try
-      if Result = atUnknown then
-        Result := AbDetermineArcType(FS)
-      else begin
-        case Result of
-          atZip : begin
-            Result := VerifyZip(FS);
-          end;
-          atSelfExtZip : begin
-            Result := VerifySelfExtracting(FS);
-          end;
-          atTar : begin
-            Result := VerifyTar(FS);
-          end;
-          atGzip, atGzippedTar: begin
-            Result := VerifyGzip(FS);
-          end;
-          {$IFDEF MSWINDOWS}
-          atCab : begin
-            Result := VerifyCab(FS);
-          end;
-          {$ENDIF}
-          atBzip2, atBzippedTar: begin
-            Result := VerifyBzip2(FS);
-          end;
-        end;
-      end;
-    finally
-      FS.Free;
-    end;
-  end;
 end;
 { -------------------------------------------------------------------------- }
 function AbDetermineArcType(aStream: TStream): TAbArchiveType;
@@ -591,7 +577,7 @@
     Result := VerifyGzip(aStream);
   if Result = atUnknown then
     Result := VerifyBzip2(aStream);
-  {$IFDEF MSWINDOWS}
+  {$IF DEFINED(ExtractCabSupport)}
   if Result = atUnknown then
     Result := VerifyCab(aStream);
   {$ENDIF}
Index: AbDfInW.pas
===================================================================
--- AbDfInW.pas	(revision 512)
+++ AbDfInW.pas	(working copy)
@@ -261,8 +261,7 @@
     HashInx :=
        ((HashInx shl c_HashShift) xor longint(CurPos[2])) and
        c_HashMask;
-    HashChains^[longint(CurPos) and FWinMask] :=
-       HashHeads^[HashInx];
+    HashChains^[PtrUInt(CurPos) and FWinMask] := HashHeads^[HashInx];
     HashHeads^[HashInx] := CurPos;
     inc(CurPos);
   end;
@@ -367,7 +366,6 @@
   {$ENDIF}
 {$ENDIF}
 type
-  PLongint = ^longint;
   PWord    = ^word;
 var
   MaxLen     : longint;
@@ -406,7 +404,7 @@
 
   {update the chain itself: set the entry for this position equal to
    the previous string position}
-  FHashChains^[longint(CurPos) and FWinMask] := PrevStrPos;
+  FHashChains^[PtrUInt(CurPos) and FWinMask] := PrevStrPos;
 
   {calculate the maximum match we could do at this position}
   MaxMatch := (FLookAheadEnd - CurPos);
@@ -602,7 +600,7 @@
       Break;
 
     {otherwise move onto the next position}
-    PrevStrPos := FHashChains^[longint(PrevStrPos) and FWinMask];
+    PrevStrPos := FHashChains^[PtrUInt(PrevStrPos) and FWinMask];
   end;
   {$ENDIF}
 
@@ -700,13 +698,11 @@
 end;
 {--------}
 procedure TAbDfInputWindow.iwSlide;
-type
-  PLongint = ^longint;
 var
   i : integer;
-  ByteCount : integer;
-  Buffer    : longint;
-  ListItem  : PLongint;
+  ByteCount : PtrInt;
+  Buffer    : PAnsiChar;
+  ListItem  : PPointer;
 begin
   {move current valid data back to the start of the buffer}
   ByteCount := FLookAheadEnd - FStart;
@@ -719,22 +715,22 @@
   dec(FLookAheadEnd, ByteCount);
 
   {patch up the hash table: the head pointers}
-  Buffer := longint(FBuffer);
-  ListItem := PLongint(@FHashHeads^[0]);
+  Buffer := FBuffer;
+  ListItem := @FHashHeads^[0];
   for i := 0 to pred(c_HashCount) do begin
     dec(ListItem^, ByteCount);
     if (ListItem^ < Buffer) then
-      ListItem^ := 0;
-    inc(PAnsiChar(ListItem), sizeof(pointer));
+      ListItem^ := nil;
+    inc(ListItem);
   end;
 
   {..the chain pointers}
-  ListItem  := PLongint(@FHashChains^[0]);
+  ListItem  := @FHashChains^[0];
   for i := 0 to pred(FWinSize) do begin
     dec(ListItem^, ByteCount);
     if (ListItem^ < Buffer) then
-      ListItem^ := 0;
-    inc(PAnsiChar(ListItem), sizeof(pointer));
+      ListItem^ := nil;
+    inc(ListItem);
   end;
 
   {now read some more data from the stream}
Index: AbDfStrm.pas
===================================================================
--- AbDfStrm.pas	(revision 512)
+++ AbDfStrm.pas	(working copy)
@@ -230,7 +230,8 @@
   {save the on progress handler}
   if Assigned(aOnProgress) and (aStreamSize > 0) then begin
     FOnProgress := aOnProgress;
-    FStreamSize := aStreamSize;
+    //FStreamSize := aStreamSize;
+    FStreamSize := aStream.Size - aStream.Position;
   end;
 end;
 {--------}
Index: AbZBrows.pas
===================================================================
--- AbZBrows.pas	(revision 512)
+++ AbZBrows.pas	(working copy)
@@ -129,7 +129,7 @@
 implementation
 
 uses
-  SysUtils, AbBzip2Typ, AbExcept, AbGzTyp, AbTarTyp, AbUtils;
+  SysUtils, AbBzip2Typ, AbExcept, AbGzTyp, AbTarTyp, AbUtils, DCOSUtils;
 
 { TAbCustomZipBrowser implementation ======================================= }
 
@@ -205,7 +205,7 @@
   FArchive := nil;
 
   if FileName <> '' then begin
-    if FileExists(FileName) then begin { open it }
+    if mbFileExists(FileName) then begin { open it }
       ArcType := ArchiveType;
       if not ForceType then
          ArcType := AbDetermineArcType(FileName, atUnknown);
Index: AbZipKit.pas
===================================================================
--- AbZipKit.pas	(revision 512)
+++ AbZipKit.pas	(working copy)
@@ -93,6 +93,8 @@
       {extract all tagged items from the archive}
     procedure ExtractToStream(const aFileName : string; ToStream : TStream);
       {extract the specified item to TStream descendant}
+    procedure TestItemAt(Index : Integer);
+      {test specific item in the archive}
     procedure TestTaggedItems;
       {test all tagged items in the archive}
 
@@ -253,6 +255,14 @@
     (ZipArchive as TAbZipArchive).PasswordRetries := Value;
 end;
 { -------------------------------------------------------------------------- }
+procedure TAbCustomZipKit.TestItemAt(Index : Integer);
+begin
+  if (ZipArchive <> nil) then
+    ZipArchive.TestItemAt(Index)
+  else
+    raise EAbNoArchive.Create;
+end;
+{ -------------------------------------------------------------------------- }
 procedure TAbCustomZipKit.TestTaggedItems;
   {test all tagged items in the archive}
 begin
